@page "/e"
@using RosbridgeNet.RosbridgeClient.Common.Attributes
@using RosbridgeNet.RosbridgeClient.Common.Interfaces
@using RosbridgeNet.RosbridgeClient.ProtocolV2.Generics
@inject IRosbridgeMessageDispatcher MessageDispatcher
@using Microsoft.AspNetCore.Components.Web
@rendermode InteractiveServer

<h3>Rosbridge Communication</h3>
<MudButton @onclick="Test">Test</MudButton>

<div tabindex="0" @onkeydown="HandleKeyPress" style="border: 1px solid black; padding: 10px;">
    <p style="font-weight: bold; margin-bottom: 10px;">Nhấn các phím để điều khiển robot</p>
    <table style="width: 100%; border-collapse: collapse;">
        <tr>
            <td style="padding: 5px;"><b>i</b>: tiến</td>
            <td style="padding: 5px;"><b>u</b>: tiến trái</td>
            <td style="padding: 5px;"><b>o</b>: tiến phải</td>
        </tr>
        <tr>
            <td style="padding: 5px;"><b>k</b>: dừng</td>
            <td style="padding: 5px;"><b>j</b>: quay cùng chiều kim đồng hồ</td>
            <td style="padding: 5px;"><b>l</b>: quay ngược chiều kim đồng hồ</td>
        </tr>
        <tr>
            <td style="padding: 5px;"><b>,</b>: lùi</td>
            <td style="padding: 5px;"><b>m</b>: lùi trái</td>
            <td style="padding: 5px;"><b>.</b>: lùi phải</td>
        </tr>
    </table>
</div>

<p>@message</p>
<p>Position: (x: @positionX, y: @positionY, z: @positionZ)</p>
<p>Orientation: (x: @orientationX, y: @orientationY, z: @orientationZ, w: @orientationW)</p>

@code
{
    private string message = "Waiting for message...";
    private double positionX = 0.0;
    private double positionY = 0.0;
    private double positionZ = 0.0;
    private double orientationX = 0.0;
    private double orientationY = 0.0;
    private double orientationZ = 0.0;
    private double orientationW = 0.0;


    private async Task PublishMessage(Twist twist)
    {
        try
        {
            var publisher = new RosPublisher<Twist>(MessageDispatcher, "/cmd_vel");
            await publisher.AdvertiseAsync();
            await publisher.PublishAsync(twist);
        }
        catch (Exception ex)
        {
            Console.WriteLine(ex.ToString());
        }
    }

    private async Task HandleKeyPress(KeyboardEventArgs e)
    {
        switch (e.Key)
        {
            case "i":
                await MoveForward();
                break;
            case "u":
                await MoveForwardLeft();
                break;
            case "o":
                await MoveForwardRight();
                break;
            case "k":
                await Stop();
                break;
            case "j":
                await TurnClockwise();
                break;
            case "l":
                await TurnCounterClockwise();
                break;
            case ",":
                await MoveBackward();
                break;
            case "m":
                await MoveBackwardLeft();
                break;
            case ".":
                await MoveBackwardRight();
                break;
        }
    }

    public float a = 0.2f;
    public float b = 0.5f;

    private async Task MoveForward()
    {
        await PublishMessage(new Twist()
            {
                linear = new Vector() { x = a, y = 0, z = 0 },
                angular = new Vector() { x = 0, y = 0, z = 0 }
            });
    }

    private async Task MoveForwardLeft()
    {
        await PublishMessage(new Twist()
            {
                linear = new Vector() { x = a, y = 0, z = 0 },
                angular = new Vector() { x = 0, y = 0, z = b }
            });
    }

    private async Task MoveForwardRight()
    {
        await PublishMessage(new Twist()
            {
                linear = new Vector() { x = a, y = 0, z = 0 },
                angular = new Vector() { x = 0, y = 0, z = -b }
            });
    }

    private async Task Stop()
    {
        await PublishMessage(new Twist()
            {
                linear = new Vector() { x = 0, y = 0, z = 0 },
                angular = new Vector() { x = 0, y = 0, z = 0 }
            });
    }

    private async Task TurnClockwise()
    {
        await PublishMessage(new Twist()
            {
                linear = new Vector() { x = 0, y = 0, z = 0 },
                angular = new Vector() { x = 0, y = 0, z = -b }
            });
    }

    private async Task TurnCounterClockwise()
    {
        await PublishMessage(new Twist()
            {
                linear = new Vector() { x = 0, y = 0, z = 0 },
                angular = new Vector() { x = 0, y = 0, z = b }
            });
    }

    private async Task MoveBackward()
    {
        await PublishMessage(new Twist()
            {
                linear = new Vector() { x = -a, y = 0, z = 0 },
                angular = new Vector() { x = 0, y = 0, z = 0 }
            });
    }

    private async Task MoveBackwardLeft()
    {
        await PublishMessage(new Twist()
            {
                linear = new Vector() { x = -a, y = 0, z = 0 },
                angular = new Vector() { x = 0, y = 0, z = b }
            });
    }

    private async Task MoveBackwardRight()
    {
        await PublishMessage(new Twist()
            {
                linear = new Vector() { x = -a, y = 0, z = 0 },
                angular = new Vector() { x = 0, y = 0, z = -b }
            });
    }

    private void Test()
    {
        Console.WriteLine("test");
    }

    public void Dispose()
    {
        // Dọn dẹp tài nguyên nếu cần
    }
    [RosMessageType("geometry_msgs/Twist")]
    public class Twist
    {
        public Vector? linear { get; set; }
        public Vector? angular { get; set; }

        public override string ToString()
        {
            return $"linear: {linear}, angular: {angular}";
        }
    }

    public class Vector
    {
        public float x { get; set; }
        public float y { get; set; }
        public float z { get; set; }

        public override string ToString()
        {
            return $"x: {x}, y: {y}, z: {z}";
        }
    }

}
